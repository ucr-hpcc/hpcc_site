<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HPCC – Linux Basics</title><link>https://hpcc.ucr.edu/manuals/linux_basics/</link><description>Recent content in Linux Basics on HPCC</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hpcc.ucr.edu/manuals/linux_basics/index.xml" rel="self" type="application/rss+xml"/><item><title>Manuals: Command Line Basics</title><link>https://hpcc.ucr.edu/manuals/linux_basics/cmdline_basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/cmdline_basics/</guid><description>
&lt;h2 id="basics">Basics&lt;/h2>
&lt;h3 id="syntax-and-notes">Syntax and Notes&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Remember the UNIX/Linux command line is case sensitive!&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The hash (pound) sign &lt;code>#&lt;/code> indicates end of a command and the start of a comment.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The notation &lt;code>&amp;lt;...&amp;gt;&lt;/code> refers to variables and file names that need to be specified by the user. The symbols &lt;code>&amp;lt;&lt;/code> and &lt;code>&amp;gt;&lt;/code> need to be excluded.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>No need to memorize all of these commands, by using these commands you will naturally memorize the most frequently used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When specifying file names:&lt;/p>
&lt;ul>
&lt;li>The &lt;code>.&lt;/code> (dot) refers to the present working directory&lt;/li>
&lt;li>The &lt;code>~&lt;/code> (tilde) refers to user&amp;rsquo;s home directory&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="commands">Commands&lt;/h3>
&lt;h4 id="navigation-and-exploration">Navigation and Exploration&lt;/h4>
&lt;pre>&lt;code class="language-bash">pwd # &amp;quot;Print working directory&amp;quot;; show your current path
ls # &amp;quot;List&amp;quot; contents of current directory
ls -l # Similar to ls, but provides additional info on files and directories
ls -a # List all files, including hidden files (.name) as well
ls -R # Lists subdirectories recursively
ls -t # Lists files in chronological order
cd &amp;lt;dir_name&amp;gt; # &amp;quot;Change directory&amp;quot; to specified path
cd # Brings you to your home directory
cd ~ # Also bring you to your home directory
cd .. # Moves one directory up
cd ../../ # Moves two directories up (and so on)
cd - # Go back to you were previously (before the last directory change)
&lt;/code>&lt;/pre>
&lt;h4 id="informative">Informative&lt;/h4>
&lt;pre>&lt;code class="language-bash">file &amp;lt;file-name&amp;gt; # Show type of file (text, binary, compressed, etc...)
id # Shows your user name and associated groups
hostname # Shows the name of the machine your shell is currently on
&lt;/code>&lt;/pre>
&lt;h4 id="files-and-directories">Files and Directories&lt;/h4>
&lt;pre>&lt;code class="language-bash">mkdir &amp;lt;dir_name&amp;gt; # Creates specified directory
rmdir &amp;lt;dir_name&amp;gt; # Removes empty directory
rm &amp;lt;file_name&amp;gt; # Removes file_name
rm -r &amp;lt;dir_name&amp;gt; # Removes directory including its contents, but asks for confirmation
rm -rf &amp;lt;dir_name&amp;gt; # Same as above, but turns confirmation off. Use with caution
cp &amp;lt;name&amp;gt; &amp;lt;path&amp;gt; # Copy file/directory as specified in path (-r to include content in directories)
mv &amp;lt;name1&amp;gt; &amp;lt;name2&amp;gt; # Renames directories or files
mv &amp;lt;name&amp;gt; &amp;lt;path&amp;gt; # Moves file/directory as specified in path
&lt;/code>&lt;/pre>
&lt;h3 id="copy-and-paste">Copy and paste&lt;/h3>
&lt;p>The methods to copy and paste on the command line differ depending on your operating systems (ie. Mac OSX, MS Windows, Linux) and your SSH application (ie. Terminal, MobaXTerm).&lt;/p>
&lt;ul>
&lt;li>Linux (xterm)&lt;/li>
&lt;/ul>
&lt;pre>&lt;code># Copy
CTRL+SHIFT+C
# Paste
CTRL+SHIFT+V
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>MS Windows (MobaXTerm)&lt;/li>
&lt;/ul>
&lt;pre>&lt;code># Copy by highlighting with mouse
# Paste
SHIFT+INSERT
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>Mac OSX (Terminal)&lt;/li>
&lt;/ul>
&lt;pre>&lt;code># Copy
COMMAND+c
# Paste
COMMAND+v
&lt;/code>&lt;/pre>
&lt;h3 id="shortcuts">Shortcuts&lt;/h3>
&lt;h4 id="command-history">Command History&lt;/h4>
&lt;ul>
&lt;li>↑&lt;code> # Up arrow key scrolls backwards through command history&lt;/code>&lt;/li>
&lt;li>↓&lt;code> # Down arrow key scrolls forwards through command history&lt;/code>&lt;/li>
&lt;li>&lt;code>history # Shows all commands you have used recently&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="auto-completion">Auto-completion&lt;/h4>
&lt;p>The tab (⇥) key auto completes commands or file names if there is only one option.
Hitting the tab (⇥) key twice will list multiple options.
Keep in mind that there are no spaces between the tab (⇥) keys and the partial names of commands or files.&lt;/p>
&lt;p>Show all directories under my home that I can &lt;code>cd&lt;/code> into:&lt;/p>
&lt;p>&lt;code>cd ~/&lt;/code>⇥⇥&lt;/p>
&lt;p>Show all files that I can &lt;code>ls&lt;/code> with names that start with &amp;ldquo;myfile&amp;rdquo;:&lt;/p>
&lt;p>&lt;code>ls myfile&lt;/code>⇥⇥&lt;/p>
&lt;p>Show all commands that I can run with names that start with &amp;ldquo;sp&amp;rdquo;:&lt;/p>
&lt;p>&lt;code>sp&lt;/code>⇥⇥&lt;/p>
&lt;h4 id="cursor">Cursor&lt;/h4>
&lt;pre>&lt;code class="language-bash">Ctrl+a # Cursor to beginning of command line
Ctrl+e # Cursor to end of command line
Ctrl+w # Cut last word
Ctrl+k # Cut to the end of the line
Ctrl+y # Paste (&amp;quot;yank&amp;quot;) content that was cut earlier (by Ctrl-w or Ctrl-k)
&lt;/code>&lt;/pre>
&lt;h3 id="other-useful-unix-commands">Other Useful Unix Commands&lt;/h3>
&lt;pre>&lt;code class="language-bash">df -h /scratch # Show local disk space for /scratch, do not use for /rhome or /bigdata
free -h # Show memory of current machine
bc # Command-line calculator (to exit type 'quit')
wget &amp;lt;URL&amp;gt; # Download a file or directory from the web
ln -s &amp;lt;FILENAME1&amp;gt; &amp;lt;FILENAME2&amp;gt; # Creates symbolic link (shortcut, or alias) for file or directory
du -sh . # Shows size of current directory
du -sh &amp;lt;FILENAME&amp;gt; # Shows size of individual file
du -s * | sort -nr # Shows size of each file within current directory, sorted by size
&lt;/code>&lt;/pre>
&lt;h2 id="help">Help&lt;/h2>
&lt;p>Not all command have help documentation available, however one of these methods will likely work:&lt;/p>
&lt;pre>&lt;code class="language-bash">help &amp;lt;COMMAND&amp;gt; # Show help for a Bash command
man &amp;lt;COMMAND&amp;gt; # Show the manual page for a program (press the 'q' key to exit)
&amp;lt;COMMAND&amp;gt; --help # Show help documentation for command
&amp;lt;COMMAND&amp;gt; -h # Show help documentation for command
&lt;/code>&lt;/pre>
&lt;p>Online help: &lt;a href="https://www.google.com/">Google&lt;/a> is your friend.&lt;/p>
&lt;p>Universally available Linux commands, with detailed examples and explanations: &lt;a href="https://www.linuxconfig.org/linux-commands">https://www.linuxconfig.org/linux-commands&lt;/a>&lt;/p></description></item><item><title>Manuals: File Systems and Transfers</title><link>https://hpcc.ucr.edu/manuals/linux_basics/filesystems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/filesystems/</guid><description>
&lt;h2 id="file-systems">File Systems&lt;/h2>
&lt;p>The file system in Linux is where you can save data, files, scripts, etc.
There are different storage pools based on the path.
In Linux you can provide any storage pool from any directory, not like MS Windows systems, where a drive letter is assigned to each storage pool (ie. &amp;ldquo;C:&amp;rdquo;,&amp;ldquo;D:&amp;quot;).
This means that by navigating through nested directories, you may find different capacity limits, depending on where you are.&lt;/p>
&lt;h2 id="locations">Locations&lt;/h2>
&lt;p>Most unix system, including Linux, have a common directory hierarchy. The following is called the &lt;code>root&lt;/code> level, since it is at the &amp;ldquo;top&amp;rdquo; like roots of a inverted tree:&lt;/p>
&lt;pre>&lt;code>/
|-- bigdata
|-- bin
|-- boot
|-- dev
|-- etc
|-- home
|-- lib
|-- lib64
|-- media
|-- mnt
|-- opt
|-- proc
|-- rhome
|-- root
|-- run
|-- sbin
|-- srv
|-- sys
|-- tmp
|-- usr
`-- var
&lt;/code>&lt;/pre>
&lt;p>The two most important directories are &lt;code>/rhome&lt;/code> and &lt;code>/bigdata&lt;/code>, since this is where your code and data will be stored.
These two directories are IBM Spectrum Scale (GPFS) pools, so storage quotas apply.
Your home directory lives directly under &lt;code>/rhome&lt;/code> and your groups shared storage lives under &lt;code>/bigdata&lt;/code> (if extra storage was purchased).
These two &amp;ldquo;bigdata&amp;rdquo; directories &lt;code>/bigdata/groupname/username&lt;/code> and &lt;code>/bigdata/groupname/shared&lt;/code> are symlinked (alias/shortcut) to your home directory for convenience, as seen here:&lt;/p>
&lt;pre>&lt;code>/
|-- bigdata
|-- groupname (Quota based on purchase)
|-- username &amp;lt;-------------|
|-- shared &amp;lt;----------| |
|-- bin | |
|-- boot | |
|-- dev | |
|-- etc | |
|-- home | |
|-- lib | |
|-- lib64 | |
|-- media | |
|-- mnt | |
|-- opt | |
|-- proc | |
|-- rhome | |
|-- username (20GB Quota) | |
|-- shared ----------&amp;gt;| |
|-- bigdata --------------&amp;gt;|
|-- root
|-- run
|-- sbin
|-- srv
|-- sys
|-- tmp
|-- usr
`-- var
&lt;/code>&lt;/pre>
&lt;p>For more information regarding these locations, and others, visit &lt;a href="../../manuals/hpc_cluster/storage/">HPCC Cluster: Data Storage&lt;/a>.&lt;/p>
&lt;h3 id="case-sensitive">Case sensitive&lt;/h3>
&lt;p>All paths and commands are case sensitive, an uppercase letter is not the same as a lowercase letter.&lt;/p>
&lt;h3 id="path-types">Path Types&lt;/h3>
&lt;p>An absolute path is a full path from top to bottom, from the &lt;code>root&lt;/code> to the &lt;code>leaf&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-bash">/rhome/username/example_dir/example_file
&lt;/code>&lt;/pre>
&lt;p>A relative path is a partial path with the current working directory is the starting point:&lt;/p>
&lt;pre>&lt;code class="language-bash">example_dir/example_file
&lt;/code>&lt;/pre>
&lt;h2 id="commands">Commands&lt;/h2>
&lt;p>Here are many common commands related to files and file systems (run &lt;code>man &amp;lt;command&amp;gt;&lt;/code> for more information):&lt;/p>
&lt;pre>&lt;code>pwd # Print working directory
ls # List files in directory
touch # Make an empty file
mkdir # Make a directory
cd # Change to directory
cp # Copy file[s] from a directory to a directory
mv # Move file[s] from a directory to a directory
rm # Remove a file
rmdir # Remove an empty directory
df # Check size of storage pool
du # Check size of file or directory
check_quota # Check quota for home and bigdata
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>Note: &lt;code>CTRL+c&lt;/code> will cancel a running command&lt;/p>
&lt;/blockquote>
&lt;h2 id="file-transfers">File Transfers&lt;/h2>
&lt;p>This section has moved to the &lt;a href="https://hpcc.ucr.edu/manuals/hpc_cluster/sharing/">Data Sharing&lt;/a> page.&lt;/p></description></item><item><title>Manuals: Permissions and Ownership</title><link>https://hpcc.ucr.edu/manuals/linux_basics/permissions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/permissions/</guid><description>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>In Linux (and Unix systems in general), access to files and directories is
controlled by a system of owners, groups, and permission bits. Changing these
settings is necessary to control access by other users.
The permission system also affects what files can be executed.&lt;/p>
&lt;h2 id="ownership-levels">Ownership Levels&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>user (u)&lt;/strong> - User ownership of a file/directory. This user has the special
right to change the permission bits and group ownership.&lt;/li>
&lt;li>&lt;strong>group (g)&lt;/strong> - Group ownership of a file/directory. Members of this group may
be assigned greater access rights than non-members.&lt;/li>
&lt;li>&lt;strong>other (o)&lt;/strong> - Everyone else that isn&amp;rsquo;t the owning user or from the owning
group.&lt;/li>
&lt;/ul>
&lt;h2 id="permission-bits">Permission Bits&lt;/h2>
&lt;p>The elemental permissions in Linux/Unix are read, write, and execute. Users and
groups can have one many, or none of these rights. Their meanings are as follows:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Letter&lt;/th>
&lt;th>Number&lt;/th>
&lt;th>File&lt;/th>
&lt;th>Directory&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Read&lt;/td>
&lt;td>r&lt;/td>
&lt;td>4&lt;/td>
&lt;td>View the contents&lt;/td>
&lt;td>View the listings&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Write&lt;/td>
&lt;td>w&lt;/td>
&lt;td>2&lt;/td>
&lt;td>Modify the contents&lt;/td>
&lt;td>Create a new file, or rename or delete existing files&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Execute&lt;/td>
&lt;td>x&lt;/td>
&lt;td>1&lt;/td>
&lt;td>Execute a program/script&lt;/td>
&lt;td>Traversal rights&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="checking-permissions">Checking Permissions&lt;/h2>
&lt;p>Annotated output for &lt;code>ls -la&lt;/code>:&lt;/p>
&lt;pre>&lt;code>---------- File type (d = directory, - = regular file, l = symlink)
|--------- User permission triplet
|| ------ Group permission triplet
|| | --- Other permission triplet
|| | |
|| | | [user] [group]
drwx-----x 61 username groupname 4096 Feb 24 16:39 ./
drwxr-xr-x 688 root root 262144 Feb 24 11:05 ../
drwx------ 2 username groupname 4096 Feb 2 22:45 .ssh/
drwxr-xr-x 5 username groupname 4096 Dec 12 15:57 Downloads/
drwxr-xr-x 2 username groupname 4096 Jan 9 16:29 bin/
-rw------- 1 username groupname 7960 Feb 23 18:37 .bash_history
-rw-r--r-- 1 username groupname 306 Nov 3 15:08 .bashrc
-rw-r--r-- 1 username groupname 677 Apr 8 2013 .profile
-rw-r--r-- 1 username groupname 128 Nov 30 12:38 .tmux.conf
-rw-r--r-- 1 username groupname 12126 Nov 2 13:14 .vimrc
lrwxrwxrwx 1 username groupname 23 Sep 12 10:49 bigdata -&amp;gt; /bigdata/groupname/username/
-rw-r--r-- 1 username groupname 5657 Sep 19 11:31 bookmarks.html
lrwxrwxrwx 1 username groupname 23 Sep 12 10:49 shared -&amp;gt; /bigdata/groupname/shared/
&lt;/code>&lt;/pre>
&lt;p>Assign write and execute permissions to user and group&lt;/p>
&lt;p>&lt;code>chmod ug+rx my_file&lt;/code>&lt;/p>
&lt;p>To remove all permissions from all three user groups&lt;/p>
&lt;pre>&lt;code class="language-bash">chmod ugo-rwx my_file
# '+' causes the permissions selected to be added
# '-' causes them to be removed
# '=' causes them to be the only permissions that the file has.
chmod +rx public_html/ or $ chmod 755 public_html/ # Example for number system:
&lt;/code>&lt;/pre>
&lt;h2 id="change-ownership">Change ownership&lt;/h2>
&lt;pre>&lt;code class="language-bash">chown &amp;lt;user&amp;gt; &amp;lt;file or dir&amp;gt; # changes user ownership
chgrp &amp;lt;group&amp;gt; &amp;lt;file or dir&amp;gt; # changes group ownership
chown &amp;lt;user&amp;gt;:&amp;lt;group&amp;gt; &amp;lt;file or dir&amp;gt; # changes user &amp;amp; group ownership
&lt;/code>&lt;/pre></description></item><item><title>Manuals: Finding Things</title><link>https://hpcc.ucr.edu/manuals/linux_basics/finding_things/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/finding_things/</guid><description>
&lt;h2 id="find-files">Find Files&lt;/h2>
&lt;pre>&lt;code class="language-bash">find ~ -name &amp;quot;*pattern*&amp;quot; # Searches for *pattern* in and below your home directory
find ~ -iname &amp;quot;*pattern*&amp;quot; # Same as above, but case insensitive
find ~ -type f -mtime -2 # Searches for files you have modified in the last two days
&lt;/code>&lt;/pre>
&lt;p>Useful &lt;code>find&lt;/code> arguments:&lt;/p>
&lt;ul>
&lt;li>&lt;code>-user &amp;lt;userName&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>-group &amp;lt;groupName&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>-ctime &amp;lt;number of days ago changed&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>-exec &amp;lt;command to run on each file&amp;gt; {} \;&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="find-text">Find Text&lt;/h2>
&lt;pre>&lt;code class="language-bash">grep &amp;quot;pattern&amp;quot; &amp;lt;FILENAME&amp;gt; # Provides lines in a file where &amp;quot;pattern&amp;quot; appears
grep -H &amp;quot;pattern&amp;quot; # -H prints out file name in front of pattern
find ~ -name &amp;quot;*.txt&amp;quot; -exec grep -H &amp;quot;pattern&amp;quot; {} \; # Search lines where &amp;quot;pattern&amp;quot; appears in files with names that end with &amp;quot;.txt&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="find-applications">Find Applications&lt;/h2>
&lt;pre>&lt;code class="language-bash">which &amp;lt;APPLICATION_NAME&amp;gt; # Location of application
whereis &amp;lt;APPLICATION_NAME&amp;gt; # Searches for executables in set of directories
rpm -qa | grep &amp;quot;pattern&amp;quot; # List all RPM packages and filter based on &amp;quot;pattern&amp;quot;
&lt;/code>&lt;/pre></description></item><item><title>Manuals: Text Editors</title><link>https://hpcc.ucr.edu/manuals/linux_basics/text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/text/</guid><description>
&lt;h2 id="text-viewing">Text Viewing&lt;/h2>
&lt;p>Here are a few commands that are used to just display the text within a file:&lt;/p>
&lt;pre>&lt;code class="language-bash">more &amp;lt;FILENAME&amp;gt; # Views text, use space bar to browse, 'q' to quit
less &amp;lt;FILENAME&amp;gt; # Also views text, uses arrow keys to browse, 'q' to quit
cat &amp;lt;FILENAME&amp;gt; # Concatenates files and prints content to screen
&lt;/code>&lt;/pre>
&lt;h2 id="text-editors">Text Editors&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Nano&lt;/strong>
&lt;ul>
&lt;li>A simple terminal-based editor.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Neovim&lt;/strong>
&lt;ul>
&lt;li>Non-graphical (terminal-based) editor. Neovim is an improved version of vim.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Vim&lt;/strong> &lt;strong>Gvim&lt;/strong>
&lt;ul>
&lt;li>Non-graphical (&lt;code>vim&lt;/code>) or window-based editor (&lt;code>gvim&lt;/code>). Vim is the improved version of vi.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Emacs&lt;/strong>
&lt;ul>
&lt;li>Non-graphical or window-based editor.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Visual Studio Code&lt;/strong>
&lt;ul>
&lt;li>Graphical editor that runs on your local machine that supports different plugins.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="nano">Nano&lt;/h2>
&lt;p>The &lt;code>nano&lt;/code> editor is the simplest to use and can be good for beginners:&lt;/p>
&lt;pre>&lt;code class="language-bash">nano &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it
&lt;/code>&lt;/pre>
&lt;p>Navigation in &lt;code>nano&lt;/code> uses the arrow keys, and all other commands are noted at the bottom of the screen.
The &lt;code>CTRL&lt;/code> key is used in combination with other keys to execute commands in &lt;code>nano&lt;/code>.&lt;/p>
&lt;p>For example, at the bottom of the &lt;code>nano&lt;/code> screen it is noted that &lt;code>^X&lt;/code> is used to exit.
This means you will need to hold the &lt;code>CTRL&lt;/code> key and then press &lt;code>x&lt;/code> in order to quit.
After that, just follow the on screen prompts at the bottom.&lt;/p>
&lt;p>For more &lt;code>nano&lt;/code> commands, please visit &lt;a href="https://www.nano-editor.org/dist/latest/cheatsheet.html">Overview of nano shortcuts&lt;/a>.&lt;/p>
&lt;h2 id="neovim--vim--gvim--vi">Neovim / Vim / GVim / VI&lt;/h2>
&lt;p>All of these editors follow the same principals.&lt;/p>
&lt;pre>&lt;code class="language-bash">nvim &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it
vim &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it
gvim &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it (must have XForwarding or VNC)
vi &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it
&lt;/code>&lt;/pre>
&lt;p>For more information please visit &lt;a href="../../manuals/linux_basics/vim/">Vim Manual&lt;/a>.&lt;/p>
&lt;h2 id="emacs">Emacs&lt;/h2>
&lt;p>Navigation in &lt;code>emacs&lt;/code> also uses the arrow keys. It is similar to &lt;code>nano&lt;/code>, in that, &lt;code>CTRL&lt;/code> is combined with other keys to execute commands.&lt;/p>
&lt;p>For example, to open a file, simply run the command with a file name:&lt;/p>
&lt;pre>&lt;code class="language-bash">emacs &amp;lt;FILENAME&amp;gt; # Open file if it exists, or create it
&lt;/code>&lt;/pre>
&lt;p>Then, after you have made some changes, exit by holding the &lt;code>CTRL&lt;/code> key and then pressing &lt;code>c&lt;/code>, releasing and then holding the &lt;code>CTRL&lt;/code> key once more and pressing &lt;code>c&lt;/code> again.
After that, just follow the on screen prompts at the bottom.&lt;/p>
&lt;p>For more commands in &lt;code>emacs&lt;/code> please visit &lt;a href="https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf">GNU Emacs Reference Card&lt;/a>&lt;/p>
&lt;h2 id="visual-studio-code">Visual Studio Code&lt;/h2>
&lt;h3 id="install">Install&lt;/h3>
&lt;p>This editor should be installed on your local machine (ie. workstation, laptop).
Please visit &lt;a href="https://code.visualstudio.com/download">Visual Studio Code&lt;/a> for software download.&lt;/p>
&lt;h3 id="remote-editing">Remote Editing&lt;/h3>
&lt;p>To setup Visual Studio Code to remotely edit files on the cluster, please refer to our guide to &lt;a href="https://hpcc.ucr.edu/manuals/hpc_cluster/selected_software/vscode/">VSCode Usage on HPCC&lt;/a>.&lt;/p>
&lt;h2 id="rstudio-server">RStudio Server&lt;/h2>
&lt;p>Two options exist to access the &lt;code>RStudio Server&lt;/code> &lt;a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE&lt;/a>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#1-shared-web-instance">Shared Web Instance&lt;/a>&lt;/li>
&lt;li>&lt;a href="#2-compute-node-instance">Compute Node Instance&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>While the &lt;code>Shared Web Instance&lt;/code> is easier for less experienced users, it does not allow to load a specific R version nor access more extensive computing resources.
Thus, experienced users may prefer the &lt;code>Compute Node Instance&lt;/code> as it does not share these limitations.&lt;/p>
&lt;h3 id="1-shared-web-instance">1. Shared Web Instance&lt;/h3>
&lt;p>R users can log in to their HPCC accounts via an RStudio Server instance.
To do so, visit the &lt;a href="https://rstudio.hpcc.ucr.edu">HPCC RStudio Server&lt;/a>.
Next provide your HPCC login credentials and click the &lt;code>Sign In&lt;/code> button.&lt;/p>
&lt;h3 id="2-compute-node-instance">2. Compute Node Instance&lt;/h3>
&lt;h4 id="a-interactive">a. Interactive&lt;/h4>
&lt;p>Alternatively, an RStudio Server instances can be started directly on a compute node and accessed via an SSH tunnel.
This involves the following steps.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>SSH into the cluster as outlined &lt;a href="https://hpcc.ucr.edu/manuals/linux_basics/intro/">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Log in to a compute node interactively via &lt;code>srun&lt;/code>, where the proper parameters need to be specified by the user.
These include partition name, RAM, number of CPU cores, wall time limit, etc. Additional details on using &lt;code>srun&lt;/code> are available
&lt;a href="https://hpcc.ucr.edu/manuals/hpc_cluster/jobs/#submitting-jobs">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">srun --partition=short --mem=8gb --cpus-per-task=2 --ntasks=1 --time=2:00:00 --pty bash -l
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>Load the latest versions of &lt;code>R&lt;/code> and &lt;code>RStudio Server&lt;/code> using the module system:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-bash">module unload R
module load R/4.2.2 # Or latest version (previously it was R/4.1.2)
module load rstudio-server/2022.02.0-443 # Or latest version (previously it was rstudio-server/2021.09.1-372)
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>Start RStudio Server:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-sh">start-rserver.sh
&lt;/code>&lt;/pre>
&lt;ol start="5">
&lt;li>Next follow the instructions printed to the terminal after running &lt;code>start-rserver.sh&lt;/code>. The command-lines given
in these instructions need be executed in a terminal of a user&amp;rsquo;s local system, and not on the remote system where
&lt;code>start-rserver.sh&lt;/code> was exectuted.&lt;/li>
&lt;/ol>
&lt;h4 id="b-non-interactive">b. Non-Interactive&lt;/h4>
&lt;p>The steps for launching an interactive job can be integrated into a script and submitted non-interactvely for a quicker deployment of a &lt;code>RStudio Server&lt;/code> instance on a compute node.
Instructions outling how to do this are located &lt;a href="https://github.com/ucr-hpcc/hpcc_slurm_examples/blob/master/rstudio-server/README.md#non-interactive">here&lt;/a>.&lt;/p>
&lt;h2 id="jupyter-server">Jupyter Server&lt;/h2>
&lt;p>Two options exist to access &lt;a href="https://jupyter.org/">JupyterLab&lt;/a>:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#1-jupyter-web-instance">Web Instance&lt;/a>&lt;/li>
&lt;li>&lt;a href="#2-jupyter-compute-node-instance">Compute Node Instance&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="1-jupyter-web-instance">1. Jupyter Web Instance&lt;/h3>
&lt;p>Users can log into their HPCC accounts via the JupyterHub server instance. To do so, visit the &lt;a href="https://jupyter.hpcc.ucr.edu/">HPCC JupyterHub server&lt;/a>. Next provide your HPCC login credentials and click the &lt;code>Sign In&lt;/code> button.&lt;/p>
&lt;p>Account changes can sometimes lead to users needing to restart active cluster sessions, and Jupyter is no different. To restart your Jupyter session, from the &amp;ldquo;File&amp;rdquo; tab click &amp;ldquo;Hub Control Panel&amp;rdquo;. From the new screen click &amp;ldquo;Stop My Server&amp;rdquo;, then &amp;ldquo;Start My Server&amp;rdquo;. After a few seconds your session will be restarted.&lt;/p>
&lt;!--
#### Choosing A Profile
There are a handful of profiles that can be selected from, below is a chart displaying the existing profiles.
| **Profile Name** | **Partition** | **Resources** | **Time Limit** | **Notes** |
|------------------|---------------|-----------------------|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Immediate Server | - | Shared | None | This will run Jupyter on a shared machine with all other users who choose this option. Choose this if you want a server with no time limit at the expense of worse performance. |
| Quick Server | Short | 2 cores, 8GB memory | 2 Hours | This is for a quick session lasting under 2 hours. Good for testing or debugging work quickly. |
| Compute Intel | Intel | 8 cores, 32GB memory | 24 hours | This will run on an Intel machine with a 24 hour time limit. |
| Compute Batch | Batch | 8 cores, 32GB memory | 24 hours | This will run on an Batch (AMD) machine with a 24 hour time limit. |
| Compute Epyc | Epyc | 8 cores, 32GB memory | 24 hours | This will run on an AMD machine with a 24 hour time limit. |
| Highmem | Highmem | 8 cores, 128GB memory | 24 hours | This will run on the highmem partition, good for jobs that require a lot of memory. |
**NOTE** that when your job reaches the specified time limit the job will be terminated and jupyter session closed. Jupyter autosaves every 2 minutes, but any new work will be lost and any running jobs cancelled once the time limit is reached.
If your job requires more flexible resources, please refer to the below section for running Jupyter directly on a compute node.
-->
&lt;h3 id="2-jupyter-compute-node-instance">2. Jupyter Compute Node Instance&lt;/h3>
&lt;h4 id="a-steps">a. Steps&lt;/h4>
&lt;p>First, start an interactive session on a compute node&lt;/p>
&lt;pre>&lt;code>srun -p epyc -t 4:00:00 -c 4 --mem=10GB --pty bash -l # Customize as needed
&lt;/code>&lt;/pre>
&lt;p>After your job has been scheduled, activate the jupyterlab module and start the server.&lt;/p>
&lt;pre>&lt;code>module load jupyterlab/
start-jupyter.sh
&lt;/code>&lt;/pre>
&lt;p>A fed seconds after running &lt;code>start-jupyter.sh&lt;/code> it will prompt you for a password. Enter a password that you would like to use to access the notebook.
NOTE: Text will not show up when you type your password, this is expected.&lt;/p>
&lt;p>&lt;img src="../../img/jupyter1.png" alt="jupyter start">&lt;/p>
&lt;p>After entering a password, it will print some text guiding you on creating a tunnel.&lt;/p>
&lt;p>&lt;img src="../../img/jupyter2.png" alt="jupyter info">&lt;/p>
&lt;p>&lt;strong>NOTE: The port and node will likely be different than pictured. This is expected, and unique to each session.&lt;/strong>&lt;/p>
&lt;p>As the text suggests, enter the &lt;code>ssh -NL&lt;/code> command in your terminal or setup MobaXTerm with the supplied details. If using the &lt;code>ssh&lt;/code> method, the &lt;strong>terminal is expected to hang after logging in and no further output should be generated.&lt;/strong>&lt;/p>
&lt;p>After a few seconds the server will start. At this point you can navigate to &amp;ldquo;http://127.0.0.1:PORT/lab&amp;rdquo; on your local machine, **replacing PORT with the port assigned when running the &lt;code>start-jupyter.sh&lt;/code> command (9345 in the example above).&lt;/p>
&lt;h4 id="b-logging-in">b. Logging In&lt;/h4>
&lt;p>After navigating to the login page, you will be prompted for the password you originally gave the notebook.&lt;/p>
&lt;p>After logging in, you can use the notebook as you would on our hosted JupyterLab server.&lt;/p>
&lt;h4 id="c-shutting-down">c. Shutting Down&lt;/h4>
&lt;p>When you are finished with your session, you can stop the Jupyter server from running by going to &amp;ldquo;File &amp;gt; Shut Down&amp;rdquo; in the notebook, or by entering Ctrl+C in the terminal window.&lt;/p></description></item><item><title>Manuals: Streams</title><link>https://hpcc.ucr.edu/manuals/linux_basics/streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/streams/</guid><description>
&lt;h2 id="streams">Streams&lt;/h2>
&lt;p>On the command line, or terminal, there are three very important lanes where information can be sent, we call these &lt;code>streams&lt;/code>.
A single command can take information in from &lt;code>STDIN&lt;/code> and then send information out on both &lt;code>STDOUT&lt;/code> and &lt;code>STDERR&lt;/code> simultaneously.&lt;/p>
&lt;h3 id="stdin">STDIN&lt;/h3>
&lt;p>For example, we can send the contents of a file as a &lt;code>STDIN&lt;/code> steam to the &lt;code>wc&lt;/code> command in order to count the lines:&lt;/p>
&lt;pre>&lt;code>wc -l &amp;lt; file.txt
&lt;/code>&lt;/pre>
&lt;h3 id="stdout">STDOUT&lt;/h3>
&lt;p>The &lt;code>STDOUT&lt;/code> steam is probably the most often used, since this is how commands send information to the screen.
However, if we do not want the information printed to the screen, we can send it into a file for later review:&lt;/p>
&lt;pre>&lt;code>ls &amp;gt; output.txt # Overwrite contents in output file with `ls` results
&lt;/code>&lt;/pre>
&lt;p>You can also append to the same file, if more information is to be saved:&lt;/p>
&lt;pre>&lt;code>ls &amp;gt;&amp;gt; output.txt # Append results from `ls` to the bottom of the file
&lt;/code>&lt;/pre>
&lt;h3 id="stderr">STDERR&lt;/h3>
&lt;p>The error stream is very useful to separate error messages (or warnings) from real output (your results).
Since there is no &lt;code>-e&lt;/code> flag for the &lt;code>ls&lt;/code> command this will generate an error. We can then store this error in a by redirecting the error stream with &lt;code>2&amp;gt;&lt;/code>.&lt;/p>
&lt;pre>&lt;code>ls -e 2&amp;gt; errors.txt
&lt;/code>&lt;/pre>
&lt;h3 id="tips">Tips&lt;/h3>
&lt;h4 id="combined-streams">Combined streams&lt;/h4>
&lt;p>If you want to combined your &lt;code>STDOUT&lt;/code> with your &lt;code>STDERR&lt;/code> stream and store it into a file, you can do this with &lt;code>&amp;amp;&amp;gt;&lt;/code>, like so:&lt;/p>
&lt;pre>&lt;code>command &amp;amp;&amp;gt; output_and_errors.txt
&lt;/code>&lt;/pre>
&lt;h4 id="trash-streams">Trash Streams&lt;/h4>
&lt;p>If you want to ignore all information from &lt;code>STDOUT&lt;/code> and &lt;code>STDERR&lt;/code> you can send both of these streams to the trash (&lt;code>/dev/null&lt;/code>):&lt;/p>
&lt;pre>&lt;code>command &amp;amp;&amp;gt; /dev/null
&lt;/code>&lt;/pre>
&lt;p>This can be useful when you are only interested in the resulting file that your command will create.&lt;/p></description></item><item><title>Manuals: Piping</title><link>https://hpcc.ucr.edu/manuals/linux_basics/pipes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/pipes/</guid><description>
&lt;h2 id="piping">Piping&lt;/h2>
&lt;p>One of the the most powerful things you can do in Linux is piping.
This allows chaining of commands so that the output (&lt;code>STDOUT&lt;/code>) of one command is the input (&lt;code>STDIN&lt;/code>) for another.
This is done by placing a &lt;code>|&lt;/code> (pipe) character between the commands.
Please note that not all commands support this, for example if your command is not taking input from &lt;code>STDIN&lt;/code>.&lt;/p>
&lt;p>As an example, let&amp;rsquo;s collect all the lines where &lt;code>pattern&lt;/code> is found in a file, then count how many lines were found:&lt;/p>
&lt;pre>&lt;code>grep 'pattern' filename | wc -l
&lt;/code>&lt;/pre>
&lt;p>You can pipe as many commands together as you like, not just two.
For example, you can combined two CSV files and extract the first column, then filter for only unique values:&lt;/p>
&lt;pre>&lt;code>cat filename1.csv filename2.csv | cut -f 1 | sort | uniq
&lt;/code>&lt;/pre>
&lt;p>For a few more simple examples, please visit here &lt;a href="https://www.guru99.com/linux-pipe-grep.html">Pipe, Grep and Sort Command in Linux/Unix with Examples&lt;/a>.
Or you can try searching Google for even more complex examples, the possibilities are endless.&lt;/p></description></item><item><title>Manuals: Variables</title><link>https://hpcc.ucr.edu/manuals/linux_basics/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/variables/</guid><description>
&lt;h2 id="variables">Variables&lt;/h2>
&lt;p>The HPCC cluster uses bash as the default shell environment. Within this environment, variables can be set and reused.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code>MYVAR=’Something’
export MYVAR=’Something’
echo $MYVAR
&lt;/code>&lt;/pre>
&lt;h3 id="default-variables">Default Variables&lt;/h3>
&lt;p>Some softwares utilize this feature and require that specific environment variables be set.
For example, every time you login, the following variables are set by default:&lt;/p>
&lt;pre>&lt;code>echo $HOME #Contains your home path
echo $USER #Contains your username
echo $PATH #Contains paths of executables
echo $LD_LIBRARY_PATH #Contains paths of library dependencies
&lt;/code>&lt;/pre>
&lt;h3 id="finding-variables">Finding Variables&lt;/h3>
&lt;p>To see a list of all variables currently set in your shell, use the &lt;code>env&lt;/code> command.
You can also &lt;code>grep&lt;/code> through this list to find variables, like so:&lt;/p>
&lt;pre>&lt;code>env | grep -i home
&lt;/code>&lt;/pre>
&lt;p>Or if you are in a &lt;code>Slurm&lt;/code> job, you can find all related &lt;code>Slurm&lt;/code> variables:&lt;/p>
&lt;pre>&lt;code>env | grep -i slurm
&lt;/code>&lt;/pre>
&lt;h3 id="setting-variables">Setting variables&lt;/h3>
&lt;p>Try to choose unique names when setting variables.
It is best to not overwrite a variable that is already set, unless on purpose.&lt;/p>
&lt;p>To set a variable in your current shell, you can do so like this:&lt;/p>
&lt;pre>&lt;code>MYVAR='Something Important'
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>Notice that there is no spaces around the &lt;code>=&lt;/code> sign.&lt;/p>
&lt;/blockquote>
&lt;p>If you would like to set a variable that is carried over to all other commands or sub-shells, then it must be &lt;code>exported&lt;/code>:&lt;/p>
&lt;pre>&lt;code>export MYVAR='Something Important'
&lt;/code>&lt;/pre></description></item><item><title>Manuals: Scripting</title><link>https://hpcc.ucr.edu/manuals/linux_basics/scripting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/scripting/</guid><description>
&lt;h2 id="scripting">Scripting&lt;/h2>
&lt;p>Converting code into a script is useful, and almost necessary when running jobs on the cluster.&lt;/p>
&lt;p>There are many benifits of doing this:&lt;/p>
&lt;ul>
&lt;li>Easy to run - blackbox&lt;/li>
&lt;li>Easy to maintain - consolidated code&lt;/li>
&lt;li>Easy to distribute - capsulated code&lt;/li>
&lt;li>Easy to automate (crontab?) - does not require interaction&lt;/li>
&lt;/ul>
&lt;h3 id="breakdown">Breakdown&lt;/h3>
&lt;p>There are four basic parts that are needed to convert your commands into a script:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>First save all your commands into a file and call it &lt;code>myscript.sh&lt;/code>, you can do this with a &lt;a href="../../manuals/linux_basics/text/">Text Editor&lt;/a> or &lt;a href="../../manuals/linux_basics/filesystems/">Transferring&lt;/a> it from your computer.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Add the &lt;code>#!&lt;/code> (SheBang) as the first line in file, this defines the interpreter. In this example, we are using &lt;code>bash&lt;/code> as the interpreter, which will run all subsequent lines in this file:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>#!/bin/bash
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>Add the proper permissions to the script, allow user (or group) execution:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>chmod u+x myscript.sh
&lt;/code>&lt;/pre>
&lt;p>OR&lt;/p>
&lt;pre>&lt;code>chmod g+x myscript.sh
&lt;/code>&lt;/pre>
&lt;ol start="4">
&lt;li>You can pass arguments via command line into a script, this step is optional, but important to note.&lt;/li>
&lt;/ol>
&lt;p>For example if I want to call my script, like so:&lt;/p>
&lt;pre>&lt;code>/where/my/script/lives/myscript.sh username number
&lt;/code>&lt;/pre>
&lt;p>Then inside my script I can capture the command line arguments into variables, like this:&lt;/p>
&lt;pre>&lt;code>username=$1
number=$2
&lt;/code>&lt;/pre>
&lt;ol start="5">
&lt;li>Lastly adding the path to a script to the &lt;code>PATH&lt;/code> environment variable, allows us to call the script without a prefixed path:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>export PATH=/where/my/script/lives/:$PATH # Can be added to .bashrc for convenience
&lt;/code>&lt;/pre>
&lt;p>After we have exported &lt;code>PATH&lt;/code> with the new path of our script, we call it like so:&lt;/p>
&lt;pre>&lt;code>myscript.sh username number
&lt;/code>&lt;/pre>
&lt;h3 id="walkthrough">Walkthrough&lt;/h3>
&lt;p>My bash commands:&lt;/p>
&lt;pre>&lt;code>sacct -n -p -u jhayes -S 2020-01-01 -l &amp;gt; myjobs.txt
cut -d'|' -f4 myjobs.txt &amp;gt; partitions.txt
wc -l partitions.txt &amp;gt; count.txt
&lt;/code>&lt;/pre>
&lt;p>Convert the above commands into a script named &lt;code>myscript.sh&lt;/code>, with the following contents:&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
# Gather Slurm job information
sacct -n -p -u jhayes -S 2020-01-01 -l &amp;gt; myjobs.txt
# Filter on parittion column
cut -d'|' -f4 myjobs.txt &amp;gt; partitions.txt
# Count how many records per partition
cat partitions.txt | sort | uniq -c &amp;gt; count.txt
&lt;/code>&lt;/pre>
&lt;p>Optional, we can alter the above commands by adding some pipes, as well as adding some variables to make this script count records for only a given partition:&lt;/p>
&lt;pre>&lt;code>#!/bin/bash -l
# Gather Slurm job information
# filter on partition column
# count how many records for given partition
sacct -n -p -u $1 -S 2020-01-01 -l | cut -d'|' -f4 | grep $2 | wc -l &amp;gt; count.txt
&lt;/code>&lt;/pre>
&lt;p>Add correct permissions:&lt;/p>
&lt;pre>&lt;code>chmod u+x myscript.sh
&lt;/code>&lt;/pre>
&lt;p>Add to my &lt;code>PATH&lt;/code>:&lt;/p>
&lt;pre>&lt;code>mkdir -p ~/bin
mv myscript.sh ~/bin
export PATH=~/bin:$PATH
&lt;/code>&lt;/pre>
&lt;p>Now run my new script:&lt;/p>
&lt;pre>&lt;code>myscript.sh
&lt;/code>&lt;/pre>
&lt;p>Or, if we did the optional step of adding variables, we can do this:&lt;/p>
&lt;pre>&lt;code>myscript.sh johndoe001 intel # Arguments are &amp;lt;USERNAME&amp;gt; and &amp;lt;PARTITION&amp;gt;
&lt;/code>&lt;/pre></description></item><item><title>Manuals: Process Management</title><link>https://hpcc.ucr.edu/manuals/linux_basics/processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/processes/</guid><description>
&lt;h2 id="process-management">Process Management&lt;/h2>
&lt;p>Basic Linux process management commands only apply to processes that are running on the current machine you are logged into.
This means that you cannot use these commands to manage jobs.
Jobs on the cluster are managed through &lt;code>Slurm&lt;/code>, see &lt;a href="../../manuals/hpc_cluster/jobs/">Cluster Jobs&lt;/a> for more details.
However, these commands are still useful for pausing, backgrounding, killing processes on a login node directly.
This commands could also be useful when running an interactive session on a compute node.&lt;/p>
&lt;h3 id="user-management">User Management&lt;/h3>
&lt;pre>&lt;code class="language-bash">top # view top consumers of memory and CPU (press 1 to see per-CPU statistics)
who # Shows who is logged into system
w # Shows which users are logged into system and what they are doing
&lt;/code>&lt;/pre>
&lt;h3 id="process-management-1">Process Management&lt;/h3>
&lt;h4 id="processes">Processes&lt;/h4>
&lt;pre>&lt;code>ps # Shows processes running by user
ps -e # Shows all processes on system; try also '-a' and '-x' arguments
ps ux -u &amp;lt;USERNAME&amp;gt; # Shows all processes owned by user
ps axjf # Shows the child-parent hierarchy of all processes
ps -o %t -p &amp;lt;PID&amp;gt; # Shows how long a particular process was running.
# (E.g. 6-04:30:50 means 6 days 4 hours ...)
&lt;/code>&lt;/pre>
&lt;p>Here are two common utilities for displaying processes, sorting, and even killing them:&lt;/p>
&lt;pre>&lt;code>top # Basic text based interface for exploring and managing processes
htop # Text based interface for exploring and managing processes
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>Note &lt;code>q&lt;/code> to quit and &lt;code>?&lt;/code> to see help&lt;/p>
&lt;/blockquote>
&lt;h4 id="background-resume-cancel">Background Resume Cancel&lt;/h4>
&lt;pre>&lt;code>CTRL+z ENTER # Suspend a process in the background
fg # Resume a suspended process and brings it into foreground
bg # Resume a suspended process but keeps it running in the background
CTRL+c # Cancel the process that is currently running in the foreground
&lt;/code>&lt;/pre>
&lt;h4 id="pid">PID&lt;/h4>
&lt;pre>&lt;code>echo $! # Get PID of last executed command
&lt;/code>&lt;/pre>
&lt;h4 id="killing">Killing&lt;/h4>
&lt;pre>&lt;code>kill -l # List all of the signals that can be sent to a process
kill &amp;lt;PID&amp;gt; # Kill a specific process with process ID using SIGTERM
kill -9 &amp;lt;PID&amp;gt; # Violently kill process with process ID using SIGKILL, may corrupt files
&lt;/code>&lt;/pre>
&lt;h3 id="more-on-terminating-processes">More on Terminating Processes&lt;/h3>
&lt;p>&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-ps-kill-and-nice-to-manage-processes-in-linux">DigitalOcean - How To Use ps, kill, and nice to Manage Processes in Linux&lt;/a>&lt;/p></description></item><item><title>Manuals: Shell Bootcamp</title><link>https://hpcc.ucr.edu/manuals/linux_basics/shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/shell/</guid><description>
&lt;h2 id="the-unix-shell">The Unix Shell&lt;/h2>
&lt;p>When you log into UNIX/LINUX system, then is starts a program called the Shell. It provides you with a working environment and interface to the operating system. Usually there are several different shell programs installed. The shell program bash is one of the most common ones.&lt;/p>
&lt;pre>&lt;code class="language-bash">finger &amp;lt;user_name&amp;gt; # shows which shell you are using
chsh -l # gives list of shell programs available on your system (does not work on all UNIX variants)
&amp;lt;shell_name&amp;gt; # switches to different shell
&lt;/code>&lt;/pre>
&lt;h3 id="stdin-stdout-stderr-redirections-and-wildcards">STDIN, STDOUT, STDERR, Redirections, and Wildcards&lt;/h3>
&lt;p>See &lt;a href="http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html">LINUX HOWTOs&lt;/a>&lt;/p>
&lt;p>By default, UNIX commands read from standard input (STDIN) and send their output to standard out (STDOUT).&lt;/p>
&lt;p>You can redirect them by using the following commands:&lt;/p>
&lt;pre>&lt;code class="language-bash">&amp;lt;beginning-of-filename&amp;gt;* # * is wildcard to specify many files
ls &amp;gt; file # prints ls output into specified file
command &amp;lt; my_file # uses file after '&amp;lt;' as STDIN
command &amp;gt;&amp;gt; my_file # appends output of one command to file
command | tee my_file # writes STDOUT to file and prints it to screen
command &amp;gt; my_file; cat my_file # writes STDOUT to file and prints it to screen
command &amp;gt; /dev/null # turns off progress info of applications by redirecting
# their output to /dev/null
grep my_pattern my_file | wc # Pipes (|) output of 'grep' into 'wc'
grep my_pattern my_non_existing_file 2 &amp;gt; my_stderr # prints STDERR to file
&lt;/code>&lt;/pre>
&lt;h3 id="useful-shell-commands">Useful shell commands&lt;/h3>
&lt;pre>&lt;code class="language-bash">cat &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt; &amp;gt; &amp;lt;cat.out&amp;gt; # concatenate files in output file 'cat.out'
paste &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt; &amp;gt; &amp;lt;paste.out&amp;gt; # merges lines of files and separates them by tabs (useful for tables)
cmp &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt; # tells you whether two files are identical
diff &amp;lt;fileA&amp;gt; &amp;lt;fileB&amp;gt; # finds differences between two files
head -&amp;lt;number&amp;gt; &amp;lt;file&amp;gt; # prints first lines of a file
tail -&amp;lt;number&amp;gt; &amp;lt;file&amp;gt; # prints last lines of a file
split -l &amp;lt;number&amp;gt; &amp;lt;file&amp;gt; # splits lines of file into many smaller ones
csplit -f out fasta_batch &amp;quot;%^&amp;gt;%&amp;quot; &amp;quot;/^&amp;gt;/&amp;quot; &amp;quot;{*}&amp;quot; # splits fasta batch file into many files
# at '&amp;gt;'
sort &amp;lt;file&amp;gt; # sorts single file, many files and can merge (-m)
# them, -b ignores leading white space, ...
sort -k 2,2 -k 3,3n input_file &amp;gt; output_file # sorts in table column 2 alphabetically and
# column 3 numerically, '-k' for column, '-n' for
# numeric
sort input_file | uniq &amp;gt; output_file # uniq command removes duplicates and creates file/table
# with unique lines/fields
join -1 1 -2 1 &amp;lt;table1&amp;gt; &amp;lt;table2&amp;gt; # joins two tables based on specified column numbers
# (-1 file1, 1: col1; -2: file2, col2). It assumes
# that join fields are sorted. If that is not the case,
# use the next command:
sort table1 &amp;gt; table1a; sort table2 &amp;gt; table2a; join -a 1 -t &amp;quot;$(echo -e '\t')&amp;quot; table1a table2a &amp;gt; table3 # '-a &amp;lt;table&amp;gt;' prints all lines of specified table!
# Default prints only all lines the two tables have in
# common. '-t &amp;quot;$(echo -e '\t')&amp;quot; -&amp;gt;' forces join to
# use tabs as field separator in its output. Default is
# space(s)!!!
cat my_table | cut -d , -f1-3 # cut command prints only specified sections of a table,
# -d specifies here comma as column separator (tab is
# default), -f specifies column numbers.
grep # see chapter 4
egrep # see chapter 4
&lt;/code>&lt;/pre>
&lt;h2 id="screen">Screen&lt;/h2>
&lt;p>Screen references&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://fosswire.com/post/2008/08/video-tutorial-getting-started-with-gnu-screen/">Screen Turorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://aperiodic.net/screen/quick_reference">Screen Cheat Sheet&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="starting-a-new-screen-session">Starting a New Screen Session&lt;/h3>
&lt;pre>&lt;code class="language-bash">screen # Start a new session
screen -S &amp;lt;some-name&amp;gt; # Start a new session and gives it a name
&lt;/code>&lt;/pre>
&lt;p>Commands to Control Screen&lt;/p>
&lt;pre>&lt;code class="language-bash">Ctrl-a d # Detach from the screen session
Ctrl-a c # Create a new window inside the screen session
Ctrl-a Space # Switch to the next window
Ctrl-a a # Switch to the window that you were previously on
Ctrl-a &amp;quot; # List all open windows. Double-quotes &amp;quot; are typed with the Shift key
Ctrl-d or type exit # Exit out of the current window. Exiting form the last window will end the screen session
Ctrl-a [ # Enters the scrolling mode. Use Page Up and Page Down keys to scroll through the window. Hit the Enter key twice to return to normal mode.
&lt;/code>&lt;/pre>
&lt;h3 id="attaching-to-screen-sessions">Attaching to Screen Sessions&lt;/h3>
&lt;p>From any computer, you can attach to a screen session after SSH-ing into a server.&lt;/p>
&lt;pre>&lt;code class="language-bash">screen -r # Attaches to an existing session, if there is only one
screen -r # Lists available sessions and their names, if there are more then one session running
screen -r &amp;lt;some-name&amp;gt; # Attaches to a specific session
screen -r &amp;lt;first-few-letters-of-name&amp;gt; # Type just the first few letters of the name
# and you will be attached to the session you need
&lt;/code>&lt;/pre>
&lt;h3 id="destroying-screen-sessions">Destroying Screen Sessions&lt;/h3>
&lt;ol>
&lt;li>Terminate all programs that are running in the screen session. The standard way to do that is: &lt;code>Ctrl-c&lt;/code>&lt;/li>
&lt;li>Exit out of your shell: &lt;code>exit&lt;/code>&lt;/li>
&lt;li>Repeat steps 1 and 2 until you see the message: &lt;code>[screen is terminating]&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>There may be programs running in different windows of the same screen session. That&amp;rsquo;s why you may need to terminate programs and exit shells multiple time.&lt;/p>
&lt;h3 id="tabs-and-a-reasonably-large-history-buffer">Tabs and a Reasonably Large History Buffer&lt;/h3>
&lt;p>For a better experience with screen, run&lt;/p>
&lt;pre>&lt;code class="language-bash">cp ~/.screenrc ~/.screenrc.backup 2&amp;gt; /dev/null
echo 'startup_message off
defscrollback 10240
caption always &amp;quot;%{=b dy}{ %{= dm}%H %{=b dy}}%={ %?%{= dc}%-Lw%?%{+b dy}(%{-b r}%n:%t%{+b dy})%?(%u)%?%{-dc}%?%{= dc}%+Lw%? %{=b dy}}&amp;quot;
' &amp;gt; ~/.screenrc
&lt;/code>&lt;/pre>
&lt;h2 id="simple-one-liner-shell-scripts">Simple One-Liner Shell Scripts&lt;/h2>
&lt;p>Web page for &lt;a href="http://linuxcommand.org/script_library.php">script download&lt;/a>.&lt;/p>
&lt;p>Renames many files *.old to *.new. To test things first, replace &amp;lsquo;do mv&amp;rsquo; with &amp;lsquo;do echo mv&amp;rsquo;:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.input; do mv $i ${i/\.old/\.new}; done
for i in *\ *; do mv &amp;quot;$i&amp;quot; &amp;quot;${i// /_}&amp;quot;; done # Replaces spaces in files by underscores
&lt;/code>&lt;/pre>
&lt;p>Run an application in loops on many input files:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.input; do ./application $i; done
&lt;/code>&lt;/pre>
&lt;p>Run fastacmd from BLAST program in loops on many *.input files and create corresponding *.out files:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.input; do fastacmd -d /data/../database_name -i $i &amp;gt; $i.out; done
&lt;/code>&lt;/pre>
&lt;p>Run SAM&amp;rsquo;s target99 on many input files:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.pep; do target99 -db /usr/../database_name -seed $i -out $i; done
Search in many files for a pattern and print occurrences together with file names.
for j in 0 1 2 3 4 5 6 7 8 9; do grep -iH &amp;lt;my_pattern&amp;gt; *$j.seq; done
&lt;/code>&lt;/pre>
&lt;p>Example of how to run an interactive application (tmpred) that asks for file name input/output:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.pep; do echo -e &amp;quot;$i\n\n17\n33\n\n\n&amp;quot; | ./tmpred $i &amp;gt; $i.out; done
&lt;/code>&lt;/pre>
&lt;p>Run BLAST2 for all &lt;em>.fasa1/&lt;/em>.fasta2 file pairs in the order specified by file names and write results into one file:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.fasta1; do blast2 -p blastp -i $i -j ${i/_*fasta1/_*fasta2} &amp;gt;&amp;gt; my_out_file; done
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>This example uses two variables in a for loop. The content of the second variable gets specified in each loop by a replace function.
&lt;/code>&lt;/pre>
&lt;p>Runs BLAST2 in all-against-all mode and writes results into one file ('-F F' turns low-complexity filter off):&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.fasta; do for j in *.fasta; do blast2 -p blastp -F F -i $i -j $j &amp;gt;&amp;gt; my_out_file; done; done;
&lt;/code>&lt;/pre>
&lt;h3 id="how-to-write-a-real-shell-script">How to write a real shell script&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Create file which contains an interpreter as the first line:&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/bash
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Place shell commands in file below the interpreter line using a text editor.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Make file executable:&lt;/p>
&lt;pre>&lt;code class="language-bash">chmod +x my_shell_script
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Run shell script like this:&lt;/p>
&lt;pre>&lt;code class="language-bash">./my_shell_script
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Place it into your /rhome/&lt;username>/bin directory&lt;/p>
&lt;pre>&lt;code class="language-bash">mkdir -p ~/bin
mv my_shell_script ~/bin/
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Add the bin path to your shell permanently:&lt;/p>
&lt;pre>&lt;code class="language-bash">echo 'export PATH=~/bin:$PATH' &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="simple-one-liner-perl-scripts">Simple One-Liner Perl Scripts&lt;/h2>
&lt;p>&lt;em>Small collection of useful one-liners:&lt;/em>&lt;/p>
&lt;pre>&lt;code class="language-perl">perl -p -i -w -e 's/pattern1/pattern2/g' my_input_file
# Replaces a pattern in a file by a another pattern using regular expressions.
# $1 or \1: back-references to pattern placed in parentheses
# -p: lets perl know to write program
# -i.bak: creates backup file *.bak, only -i doesn't
# -w: turns on warnings
# -e: executable code follows
&lt;/code>&lt;/pre>
&lt;p>&lt;em>Parse lines based on patterns:&lt;/em>&lt;/p>
&lt;pre>&lt;code class="language-perl">perl -ne 'print if (/my_pattern1/ ? ($c=1) : (--$c &amp;gt; 0)); print if (/my_pattern2/ ? ($d = 1) : (--$d &amp;gt; 0))' my_infile &amp;gt; my_outfile
# Parses lines that contain pattern1 and pattern2.
# The following lines after the pattern can be specified in '$c=1' and '$d=1'.
# For logical OR use this syntax: '/(pattern1|pattern2)/'.
&lt;/code>&lt;/pre>
&lt;h2 id="remote-copy-wget-scp-ncftp">Remote Copy: wget, scp, ncftp&lt;/h2>
&lt;h3 id="wget">Wget&lt;/h3>
&lt;p>Use wget to download a file from the web:&lt;/p>
&lt;pre>&lt;code class="language-bash">wget ftp://ftp.ncbi.nih.... # file download from www; add option '-r' to download entire directories
&lt;/code>&lt;/pre>
&lt;h3 id="scp">SCP&lt;/h3>
&lt;p>Use scp to copy files between machines (ie. laptop to server):&lt;/p>
&lt;pre>&lt;code class="language-bash">scp source target # Use form 'userid@machine_name' if your local and remote user ids are different.
# If they are the same you can use only 'machine_name'.
&lt;/code>&lt;/pre>
&lt;p>Here are more scp examples:&lt;/p>
&lt;pre>&lt;code class="language-bash">scp user@remote_host:file.name . # Copies file from server to local machine (type from local
# machine prompt). The '.' copies to pwd, you can specify # here any directory, use wildcards to copy many files.
scp file.name user@remote_host:~/dir/newfile.name
# Copies file from local machine to server.
scp -r user@remote_host:directory/ ~/dir
# Copies entire directory from server to local machine.
&lt;/code>&lt;/pre>
&lt;h3 id="nice-ftp">Nice FTP&lt;/h3>
&lt;p>From the linux command line run ncftp and use it to get files:&lt;/p>
&lt;pre>&lt;code class="language-bash">ncftp
ncftp&amp;gt; open ftp.ncbi.nih.gov
ncftp&amp;gt; cd /blast/executables
ncftp&amp;gt; get blast.linux.tar.Z (skip extension: @)
ncftp&amp;gt; bye
&lt;/code>&lt;/pre>
&lt;h2 id="archiving-and-compressing">Archiving and Compressing&lt;/h2>
&lt;h3 id="creating-archives">Creating Archives&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -cvf my_file.tar mydir/ # Builds tar archive of files or directories. For directories, execute command in parent directory. Don't use absolute path.
tar -czvf my_file.tgz mydir/ # Builds tar archive with compression of files or directories. For
# directories, execute command in parent directory. Don't use absolute path.
zip -r mydir.zip mydir/ # Command to archive a directory (here mydir) with zip.
tar -jcvf mydir.tar.bz2 mydir/ # Creates *.tar.bz2 archive
&lt;/code>&lt;/pre>
&lt;h3 id="viewing-archives">Viewing Archives&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -tvf my_file.tar
tar -tzvf my_file.tgz
&lt;/code>&lt;/pre>
&lt;h3 id="extracting-archives">Extracting Archives&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xvf my_file.tar
tar -xzvf my_file.tgz
gunzip my_file.tar.gz # or unzip my_file.zip, uncompress my_file.Z,
# or bunzip2 for file.tar.bz2
find -name '*.zip' | xargs -n 1 unzip # this command usually works for unzipping
# many files that were compressed under Windows
tar -jxvf mydir.tar.bz2 # Extracts *.tar.bz2 archive
&lt;/code>&lt;/pre>
&lt;p>Try also:&lt;/p>
&lt;pre>&lt;code class="language-bash">tar zxf blast.linux.tar.Z
tar xvzf file.tgz
&lt;/code>&lt;/pre>
&lt;p>Important options:&lt;/p>
&lt;pre>&lt;code class="language-bash">f: use archive file
p: preserve permissions
v: list files processed
x: exclude files listed in FILE
z: filter the archive through gzip
&lt;/code>&lt;/pre>
&lt;h2 id="simple-installs">Simple Installs&lt;/h2>
&lt;h3 id="systems-wide-installations">Systems-wide installations&lt;/h3>
&lt;h3 id="applications-in-user-accounts">Applications in user accounts&lt;/h3>
&lt;h3 id="installation-of-rpms">Installation of RPMs&lt;/h3>
&lt;h2 id="environment-variables">Environment Variables&lt;/h2>
&lt;pre>&lt;code class="language-bash">xhost user@host # adds X permissions for user on server.
echo $DISPLAY # shows current display settings
export DISPLAY=&amp;lt;local_IP&amp;gt;:0 # change environment variable
unsetenv DISPLAY # removes display variable
env # prints all environment variables
&lt;/code>&lt;/pre>
&lt;p>List of directories that the shell will search when you type a command:&lt;/p>
&lt;pre>&lt;code class="language-bash">echo $PATH
&lt;/code>&lt;/pre>
&lt;p>You can edit your default DISPLAY setting for your account by adding it to file .bash_profile&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="exercise-1">Exercise 1&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Download proteome of Halobacterium spec. with wget and look at it:&lt;/p>
&lt;pre>&lt;code>module load ncbi-blast/2.2.26 # Loads legacy blastall
wget ftp://ftp.ncbi.nlm.nih.gov/genomes/genbank/archaea/Halobacterium_salinarum/representative/GCA_000069025.1_ASM6902v1/GCA_000069025.1_ASM6902v1_protein.faa.gz
gunzip GCA_000069025.1_ASM6902v1_protein.faa.gz
mv GCA_000069025.1_ASM6902v1_protein.faa AE004437.faa
less AE004437.faa # press q to quit
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Simple Analysis:&lt;/p>
&lt;p>a. How many predicted proteins are there?&lt;/p>
&lt;pre>&lt;code class="language-bash">grep '^&amp;gt;' AE004437.faa --count
&lt;/code>&lt;/pre>
&lt;p>b. How many proteins contain the pattern &amp;ldquo;WxHxxH&amp;rdquo; or &amp;ldquo;WxHxxHH&amp;rdquo;?&lt;/p>
&lt;pre>&lt;code class="language-bash">egrep 'W.H..H{1,2}' AE004437.faa --count
&lt;/code>&lt;/pre>
&lt;p>c. Use the find function (/) in &amp;lsquo;less&amp;rsquo; to fish out the protein IDs containing the pattern or more elegantly do it with awk:&lt;/p>
&lt;pre>&lt;code class="language-bash">awk --posix -v RS='&amp;gt;' '/W.H..(H){1,2}/ { print &amp;quot;&amp;gt;&amp;quot; $0;}' AE004437.faa | less # press q to quit
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Create a BLASTable database with formatdb:&lt;/p>
&lt;pre>&lt;code class="language-bash">ls # before
formatdb -i AE004437.faa -p T -o T
ls # after
'-p F' for nucleotide and '-p T' for protein database; '-o T' parse SeqId and create indexes
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Generate myseq.fasta&lt;/p>
&lt;p>a. Generate list of sequence IDs for the above pattern match result (i.e. retrieve my_IDs from step 2c). Alternatively, download the pre-generated file with wget.&lt;/p>
&lt;p>b. Retrieve the corresponding sequences for these IDs with the fastacmd command from the blastable database:&lt;/p>
&lt;pre>&lt;code class="language-bash">wget https://cluster.hpcc.ucr.edu/~tgirke/Documents/UNIX/my_IDs
fastacmd -d AE004437.faa -i my_IDs &amp;gt; myseq.fasta
less myseq.fasta # press q to quit
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>(Optional) Looking at several different patterns:&lt;/p>
&lt;p>a. Generate several lists of sequence IDs from various pattern match results (i.e. retrieve a.my_ids, b.my_ids, and c.my_ids from step 2c).&lt;/p>
&lt;p>b. Retrieve the sequences in one step using the fastacmd in a for-loop:&lt;/p>
&lt;pre>&lt;code class="language-bash">for i in *.my_ids; do fastacmd -d AE004437.faa -i $i &amp;gt; $i.fasta; done
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>Run blastall with a few proteins in myseq.fasta against your newly created Halobacterium proteome database.&lt;/p>
&lt;p>Create first a complete blast output file including alignments. In a second step use the &amp;rsquo;m -8' option to obtain a tabular output (i.e. tab separated values):&lt;/p>
&lt;pre>&lt;code class="language-bash">blastall -p blastp -i myseq.fasta -d AE004437.faa -o blastp.out -e 1e-6 -v 10 -b 10
blastall -p blastp -i myseq.fasta -d AE004437.faa -m 8 -e 1e-6 &amp;gt; blastp.tab
less blastp.out # press q to quit
less -S blastp.tab # -S disables line wrapping, press q to quit
&lt;/code>&lt;/pre>
&lt;p>The filed descriptions of the Blast tabular output (from the &amp;ldquo;-m 8&amp;rdquo; option) are available here:&lt;/p>
&lt;pre>&lt;code>1 Query (The query sequence id)
2 Subject (The matching subject sequence id)
3 % id
4 alignment length
5 mismatches
6 gap openings
7 q.start
8 q.end
9 s.start
10 s.end
11 e-value
12 bit score
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;p>Is your blastp.out file equivalent to this one?&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Parse blastall output into Excel spread sheet&lt;/p>
&lt;p>a. Using biocore parser&lt;/p>
&lt;pre>&lt;code class="language-bash">blastParse -i blastp.out -o blast.xls -c 5
&lt;/code>&lt;/pre>
&lt;p>b. Using BioPerl parser&lt;/p>
&lt;pre>&lt;code class="language-bash">bioblastParse.pl blastp.out &amp;gt; blastparse.txt
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h3 id="exercise-2">Exercise 2&lt;/h3>
&lt;p>Split sample fasta batch file with csplit (use sequence file myseq.fasta from Exercise 1).&lt;/p>
&lt;pre>&lt;code class="language-bash">csplit -z myseq.fasta '/&amp;gt;/' '{*}'
&lt;/code>&lt;/pre>
&lt;p>Delete some of the files generated by csplit
Concatenate single fasta files from (step 1) into to one file with cat (e.g. &lt;code>cat file1 file2 file3 &amp;gt; bigfile&lt;/code>).
BLAST two related sequences, retrieve the result in tabular format and use &lt;code>comm&lt;/code> to identify common hit IDs in the two tables.&lt;/p>
&lt;h3 id="exercise-3">Exercise 3&lt;/h3>
&lt;p>Run HMMPFAM search with proteins from Exercise 1 against Pfam database (will take ~3 minutes)&lt;/p>
&lt;pre>&lt;code class="language-bash">hmmscan -E 0.1 --acc /srv/projects/db/pfam/2011-12-09-Pfam26.0/Pfam-A.hmm myseq.fasta &amp;gt; output.pfam
&lt;/code>&lt;/pre>
&lt;p>Easier to parse/process tabular output&lt;/p>
&lt;pre>&lt;code class="language-bash">hmmscan -E 0.1 --acc --tblout output.pfam /srv/projects/db/pfam/2011-12-09-Pfam26.0/Pfam-A.hmm myseq.fasta # also try --domtblout
&lt;/code>&lt;/pre>
&lt;p>Which query got the most hits? How many hits were found that query?&lt;/p>
&lt;h3 id="exercise-4">Exercise 4&lt;/h3>
&lt;p>Create multiple alignment with ClustalW (e.g. use sequences with &amp;lsquo;W.H..HH&amp;rsquo; pattern)&lt;/p>
&lt;pre>&lt;code class="language-bash">clustalw myseq.fasta
mv myseq.aln myalign.aln
&lt;/code>&lt;/pre>
&lt;h3 id="exercise-5">Exercise 5&lt;/h3>
&lt;p>Reformat alignment into PHYILIP format using &amp;lsquo;seqret&amp;rsquo; from EMBOSS&lt;/p>
&lt;pre>&lt;code class="language-bash">seqret clustal::myalign.aln phylip::myalign.phylip
&lt;/code>&lt;/pre>
&lt;h3 id="exercise-6">Exercise 6&lt;/h3>
&lt;p>Create neighbor-joining tree with PHYLIP&lt;/p>
&lt;pre>&lt;code class="language-bash">cp myalign.phylip infile
protdist # creates distance matrix (you may need to press 'R' and then 'Y')
cp outfile infile
neighbor # use default settings (press 'Y')
cp outtree intree
&lt;/code>&lt;/pre>
&lt;p>retree # displays tree and can use midpoint method for defining root of tree, my typical command sequence is: &amp;lsquo;N&amp;rsquo; (until you see PHYLIP) &amp;lsquo;Y&amp;rsquo; &amp;lsquo;M&amp;rsquo; &amp;lsquo;W&amp;rsquo; &amp;lsquo;R&amp;rsquo; &amp;lsquo;R&amp;rsquo; &amp;lsquo;X&amp;rsquo;&lt;/p>
&lt;pre>&lt;code class="language-bash">cp outtree tree.dnd
&lt;/code>&lt;/pre>
&lt;p>View your tree in TreeBrowse or open it in TreeView&lt;/p></description></item><item><title>Manuals: Linux Basics - Vim Manual</title><link>https://hpcc.ucr.edu/manuals/linux_basics/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hpcc.ucr.edu/manuals/linux_basics/vim/</guid><description>
&lt;blockquote>
&lt;p>Note: &lt;a href="https://neovim.io/">Neovim&lt;/a> has replaced vim on the cluster, however most (if not all) items here still apply.
Load Neovim via the module system, like so &lt;code>module load neovim&lt;/code>. It may also be useful to alias &lt;code>nvim&lt;/code> to &lt;code>vim&lt;/code>, like so &lt;code>alias vim=nvim&lt;/code>.
Thia alias can be added to your &lt;code>~/.bashrc&lt;/code> file for convenience.&lt;/p>
&lt;/blockquote>
&lt;h2 id="vim-manual">Vim Manual&lt;/h2>
&lt;p>This is an extensive overview of vim features and operations.&lt;/p>
&lt;h3 id="basics">Basics&lt;/h3>
&lt;p>&lt;code>vim &amp;lt;my_file_name&amp;gt; # open/create file with vim&lt;/code>&lt;/p>
&lt;p>Once you are in Vim the most important commands are &lt;code>i&lt;/code> , &lt;code>:&lt;/code> and &lt;code>ESC&lt;/code>. The &lt;code>i&lt;/code> key brings you into the insert mode for typing. &lt;code>ESC&lt;/code> brings you out of there. And the &lt;code>:&lt;/code> key starts the command mode at the bottom of the screen. In the following text, all commands starting with &lt;code>:&lt;/code> need to be typed in the command mode. All other commands are typed in the normal mode after hitting the &lt;code>ESC&lt;/code> key.&lt;/p>
&lt;h3 id="modifiers">Modifiers&lt;/h3>
&lt;pre>&lt;code class="language-bash">i # INSERT MODE
ESC # NORMAL (NON-EDITING) MODE
: # Commands start with ':'
:w # Save command; if you are in editing mode you have to hit ESC first!!
:q # Quit file, don't save
:q! # Exits WITHOUT saving any changes you have made
:wq # Save and quit
R # Replace MODE
r # Replace only one character under cursor
q: # History of commands (from NORMAL MODE!), to reexecute one of them, select and hit enter!
:w new_filename # Saves into new file
:#,#w new_filename # Saves specific lines (#,#) to new file
:# # Go to specified line number
&lt;/code>&lt;/pre>
&lt;h3 id="moving-around">Moving Around&lt;/h3>
&lt;pre>&lt;code class="language-bash">$ # Moves cursor to end of line
A # Same as $, but switches to insert mode
0 # Zero moves cursor to beginning of line
CTRL-g # Shows file name and current line you are on
SHIFT-G # Brings you to bottom of file
&lt;/code>&lt;/pre>
&lt;h3 id="lines">Lines&lt;/h3>
&lt;pre>&lt;code class="language-bash">:set wrap # Wrap lines around the screen if too long
:set nowrap # No line wrapping
:set number # Shows line numbers
:set nonumber # No line numbers
&lt;/code>&lt;/pre>
&lt;h3 id="multiple-files">Multiple Files&lt;/h3>
&lt;pre>&lt;code class="language-bash">vim -o *.txt # Opens many files at once and displays them with horizontal
# Split, '-O' does vertical split
vim *.txt # Opens many files at once; ':n' switches between files
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-bash">:wall or :qall # Write or quit all open files
:args *.txt # Places all the relevant files in the argument list
:all # Splits all files in the argument list (buffer) horizontally
CTRL-w # Switch between windows
:split # Shows same file in two windows
:split &amp;lt;file-to-open&amp;gt; # Opens second file in new window
:vsplit # Splits windows vertically, very useful for tables, &amp;quot;:set scrollbind&amp;quot; let's you scroll all open windows simultaneously
:close # Closes current window
:only # Closes all windows except current one
&lt;/code>&lt;/pre>
&lt;h3 id="spell-checking">Spell Checking&lt;/h3>
&lt;pre>&lt;code class="language-bash">:set spell # Turns on spell checking
:set nospell # Turns spell checking off
:! dict &amp;lt;word&amp;gt; # Meaning of word
:! wn 'word' -over # Synonyms of word
&lt;/code>&lt;/pre>
&lt;h3 id="syntax-highlighting">Syntax Highlighting&lt;/h3>
&lt;pre>&lt;code class="language-bash">:set filetype=perl # Turns on syntax coloring for a chosen programming language.
:syn on # Turns syntax highlighting on
:syn off # Turns syntax highlighting off
&lt;/code>&lt;/pre>
&lt;h3 id="undo-and-redo">Undo and Redo&lt;/h3>
&lt;pre>&lt;code class="language-bash">u # Undo last command
U # Undo all changes on current line
CTRL-R # Redo one change which was undone
&lt;/code>&lt;/pre>
&lt;h3 id="deleting">Deleting&lt;/h3>
&lt;pre>&lt;code class="language-bash">x # Deletes what is under cursor
dw # Deletes from curser to end of word including the space
de # Deletes from curser to end of word NOT including the space
cw # Deletes rest of word and lets you then insert, hit ESC to continue with NORMAL mode
c$ # Deletes rest of line and lets you then insert, hit ESC to continue with with NORMAL mode
d$ # Deletes from cursor to the end of the line
dd # Deletes entire line
2dd # Deletes next two lines, continues: 3dd, 4dd and so on.
&lt;/code>&lt;/pre>
&lt;h3 id="copy-and-paste">Copy and Paste&lt;/h3>
&lt;pre>&lt;code class="language-bash">yy # Copies line, for copying several lines do 2yy, 3yy and so on
p # Pastes clipboard behind cursor
&lt;/code>&lt;/pre>
&lt;h3 id="search">Search&lt;/h3>
&lt;pre>&lt;code class="language-bash">/my_pattern # Searches for my_pattern downwards, type n for next match
?my_pattern # Searches for my_pattern upwards, type n for next match
:set ic # Switches to ignore case search (case insensitive)
:set hls # Switches to highlight search (highlights search hits)
&lt;/code>&lt;/pre>
&lt;h3 id="replacements">Replacements&lt;/h3>
&lt;p>Great intro: &lt;a href="http://www.scootersoftware.com/RegEx.html">A Tao of Regular Expressions&lt;/a>&lt;/p>
&lt;p>Quick reference to some replacement techniques:&lt;/p>
&lt;pre>&lt;code class="language-bash">:s/old_pat/new_pat/ # Replaces first occurrence in a line
:s/old_pat/new_pat/g # Replaces all occurrence in a line
:s/old_pat/new_pat/gc # Add 'c' to ask for confirmation
:#,#s/old_pat/new_pat/g # Replaces all occurrence between line numbers: #,#
:%s/old_pat/new_pat/g # Replaces all occurrence in file
:%s/\(pattern1\)\(pattern2\)/\1test\2/g # Regular expression to insert, you need here '\' in front of parentheses (&amp;lt;# Perl)
:%s/\(pattern.*\)/\1 my_tag/g # Appends something to line containing pattern (&amp;lt;# .+ from Perl is .* in VIM)
:%s/\(pattern\)\(.*\)/\1/g # Removes everything in lines after pattern
:%s/\(At\dg\d\d\d\d\d\.\d\)\(.*\)/\1\t\2/g # Inserts tabs between At1g12345.1 and Description
:%s/\n/new_pattern/g # Replaces return signs
:%s/pattern/\r/g # Replace pattern with return signs!!
:%s/\(\n\)/\1\1/g # Insert additional return signs
:%s/\(^At\dg\d\d\d\d\d.\d\t.\{-}\t.\{-}\t.\{-}\t.\{-}\t\).\{-}\t/\1/g # Replaces content between 5th and 6th tab (5th column), '{-}' turns off 'greedy' behavior
:#,#s/\( \{-} \|\.\|\n\)/\1/g # Performs simple word count in specified range of text
:%s/\(E\{6,\}\)/&amp;lt;font color=&amp;quot;green&amp;quot;&amp;gt;\1&amp;lt;\/font&amp;gt;/g # Highlight pattern in html colors, here highlighting of &amp;gt;= 6 occurences of Es
:%s/\([A-Z]\)/\l\1/g # Change uppercase to lowercase, '%s/\([A-Z]\)/\u\1/g' does the opposite
&lt;/code>&lt;/pre>
&lt;p>Uses &amp;lsquo;global&amp;rsquo; command to apply replace function only on those lines that match a certain pattern. The &amp;lsquo;copy $&amp;rsquo; command after the pipe &amp;lsquo;|&amp;rsquo; prints all matching lines at the end of the file.&lt;/p>
&lt;pre>&lt;code class="language-bash">:g/my_pattern/ s/\([A-Z]\)/\l\1/g | copy $
&lt;/code>&lt;/pre>
&lt;p>Command &amp;lsquo;args&amp;rsquo; places all relevant files in the argument list (buffer); &amp;lsquo;all&amp;rsquo; displays each file in separate split window; command &amp;lsquo;argdo&amp;rsquo; applies replacement to all files in argument list (buffer); flag &amp;lsquo;e&amp;rsquo; is necessary to avoid stop at error messages for files with no matches; command &amp;lsquo;update&amp;rsquo; saves all changes to files that were updated.&lt;/p>
&lt;pre>&lt;code class="language-bash">:args *.txt | all | argdo %s/\old_pat/new_pat/ge | update
&lt;/code>&lt;/pre>
&lt;h3 id="utilities">Utilities&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Matching Parentheses&lt;/p>
&lt;ul>
&lt;li>Place cursor on (, [ or { and type % # cursor moves to matching parentheses&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Printing and Inserting Files&lt;/p>
&lt;ul>
&lt;li>&lt;code>:ha # Prints entire file&lt;/code>&lt;/li>
&lt;li>&lt;code>:#,#ha # Prints specified lines: #,#&lt;/code>&lt;/li>
&lt;li>&lt;code>:r &amp;lt;filename&amp;gt; # Inserts content of specified file after cursor&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Convert Text File to HTML Format&lt;/p>
&lt;ul>
&lt;li>&lt;code>:runtime! syntax/2html.vim # Run this command with open file in Vim&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Shell Commands in Vim&lt;/p>
&lt;ul>
&lt;li>&lt;code>:!&amp;lt;SHELL_COMMAND&amp;gt; &amp;lt;ENTER&amp;gt; # Executes any shell command, hit &amp;lt;enter&amp;gt; to return&lt;/code>&lt;/li>
&lt;li>&lt;code>:sh # Switches window to shell, 'exit' switches back to vim&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Using Vim as Table Editor&lt;/p>
&lt;ul>
&lt;li>&lt;code>v&lt;/code> starts visual mode for selecting characters&lt;/li>
&lt;li>&lt;code>V&lt;/code> starts visual mode for selecting lines`&lt;/li>
&lt;li>&lt;code>CTRL-V&lt;/code> starts visual mode for selecting blocks (use CTRL-q in gVim under Windows). This allows column-wise selections and operations like inserting and deleting columns. To restrict substitute commands to a column, one can select it and switch to the command-line by typing &lt;code>:&lt;/code>. After this the substitution syntax for a selected block looks like this: &lt;code>'&amp;lt;,'&amp;gt;s///.&lt;/code>&lt;/li>
&lt;li>&lt;code>:set scrollbind&lt;/code> starts simultaneous scrolling of &amp;lsquo;vsplitted&amp;rsquo; files. To set to horizontal binding of files, use command &lt;code>:set scrollopt=hor&lt;/code> (after first one). Run all these commands before the &lt;code>:split&lt;/code> command.&lt;/li>
&lt;li>&lt;code>:AlignCtrl I= \t&lt;/code> then &lt;code>:%Align&lt;/code> This allows to align tables by column separators (here &amp;lsquo;\t&amp;rsquo;) when the &lt;a href="http://vim.sourceforge.net/scripts/script.php?script_id=294">Align utility from Charles Campbell&amp;rsquo;s&lt;/a> is installed. To sort table rows by selected lines or block, perform the visual select and then hit F3 key. The rest is interactive. To enable this function, one has to include in the &lt;code>.vimrc&lt;/code> file the &lt;a href="https://cluster.hpcc.ucr.edu/%7Etgirke/Documents/UNIX/vim/vim_sort_fct.txt">Vim sort script&lt;/a> from Gerald Lai.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="settings">Settings&lt;/h3>
&lt;p>The default settings in Vim are controlled by the &lt;code>.vimrc&lt;/code> file in your home directory.&lt;/p>
&lt;ul>
&lt;li>see last chapter of vimtutor (start from shell)&lt;/li>
&lt;li>useful &lt;a href="http://phuzz.org/vimrc.html">.vimrc sample&lt;/a>&lt;/li>
&lt;li>when vim starts to respond very slowly then one may need to delete the &lt;code>.viminf*&lt;/code> files in home directory&lt;/li>
&lt;/ul>
&lt;h3 id="help">Help&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Online Help&lt;/strong>
&lt;ul>
&lt;li>Find help on the web. Google will find answers to most questions on &lt;strong>vi&lt;/strong> and &lt;strong>vim&lt;/strong> (try searching for both terms).&lt;/li>
&lt;li>&lt;a href="https://engineering.purdue.edu/ECN/Support/KB/Docs/ViTextEditorTutorial">Purdue University Vi Tutorial&lt;/a>&lt;/li>
&lt;li>Animated Vim Tutorial: &lt;a href="https://linuxconfig.org/vim-tutorial">https://linuxconfig.org/vim-tutorial&lt;/a>&lt;/li>
&lt;li>Useful list of vim commands:
&lt;ul>
&lt;li>&lt;a href="http://www.fprintf.net/vimCheatSheet.html">Vim Commands Cheat Sheet&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://tnerual.eriogerg.free.fr/vimqrc.pdf">VimCard&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>You can run a tutor from the command Line:&lt;/p>
&lt;pre>&lt;code>vimtutor # Open vim tutorial from shell, &amp;quot;:q&amp;quot; to quit
&lt;/code>&lt;/pre>
&lt;p>You can also get help from within Vim:&lt;/p>
&lt;pre>&lt;code class="language-bash">:help # opens help within vim, hit :q to get back to your file
:help &amp;lt;topic&amp;gt; # opens help on specified topic
:help_topic| CTRL-] # when you are in help this command opens help topic specified between |...|,
# CTRL-t brings you back to last topic
:help &amp;lt;topic&amp;gt; CTRL-D # gives list of help topics that contain key word
: &amp;lt;up-down keys&amp;gt; # like in shell you get recent commands!!!!
&lt;/code>&lt;/pre></description></item></channel></rss>